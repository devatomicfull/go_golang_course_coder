= Atividades do Curso de Go
:doctype: book
:toc:

== Exercício 1 — Fundamentos do Go

=== Resumo Rápido
Este exercício apresenta a **estrutura básica de um programa Go**, explicando o uso de `package main`, a função `main()` e os primeiros comandos de saída com `fmt`.

=== Objetivo
Criar o primeiro programa executável em Go entendendo as regras fundamentais de organização:

* Programas executáveis devem usar `package main`.
* A função `main()` é o ponto de entrada.
* A pasta não é um pacote reutilizável — portanto mantém `main`.
* Uso inicial de `fmt.Print`, `fmt.Println` e `fmt.Printf`.

=== O que foi feito

* Importado o pacote padrão `fmt`.
* Criado um programa que imprime mensagens formatadas no console.
* Demonstrado o uso de **escapes** (`\n`, `\`, `%s`) e a diferença entre strings normais e RAW.
* Comentado sobre boas práticas de comentários no código.

=== Como executar

```
cd 1_fundamentos
go run .
```

Ou gerar o binário:

```
go build
```

=== Conclusão
Esta atividade estabelece a base para compreender como Go organiza e executa programas, preparando para módulos, pacotes e projetos maiores.

== Exercício 2 - Comandos Go
:toc:

=== Resumo Rápido
Este programa imprime no terminal uma lista completa dos comandos principais do Go, explicando claramente para que cada um serve. Ele funciona como um guia de estudo dos comandos utilizados na linha de comando da linguagem Go.

=== Objetivo
Apresentar e explicar os comandos essenciais do Go utilizados no terminal, incluindo build, run, documentação, módulos, testes, instalação de pacotes e limpeza do ambiente.

=== O que foi feito
O código exibe no console:

* **go** → Comando principal do Go; mostra ajuda e controla o toolchain.
* **go help get** → Exibe ajuda detalhada sobre o comando `go get`.
* **go version** → Mostra a versão instalada do Go.
* **godoc -http=:6060** → Inicia um servidor local com a documentação completa da linguagem.
* **go env** → Lista variáveis de ambiente do Go (GOPATH, GOROOT, etc.).
* **go doc cmd/vet** → Exibe a documentação do comando `go vet`.
* **go vet comandos.go** → Analisa o arquivo em busca de padrões suspeitos e possíveis bugs.
* **go build comandos.go** → Compila o arquivo e gera um binário.
* **./comandos** → Executa o binário gerado (no Linux/Mac).
* **go run comandos.go** → Compila e executa sem gerar binário.
* **ls ~/go/src/github.com** → Lista pacotes instalados no GOPATH (Linux/Mac).
* **dir ~/go/src/github.com** → Lista pacotes instalados no GOPATH (Windows).
* **go get -u github.com/go-sql-driver/mysql** → Instala ou atualiza dependências.

Comandos complementares exibidos:

* **go mod init \<nome\>** → Cria um novo módulo Go.
* **go mod tidy** → Ajusta e organiza dependências.
* **go mod download** → Baixa todas as dependências do módulo.
* **go list ./...** → Lista todos os pacotes do projeto.
* **go install \<pacote\>@latest** → Instala binários e ferramentas Go.
* **go test** → Executa testes do pacote atual.
* **go test ./...** → Executa testes de todos os pacotes.
* **go fmt ./...** → Formata automaticamente todo o código Go.
* **go clean** → Remove arquivos temporários e restos de build.
* **go fix** → Atualiza código antigo para versões recentes.
* **go tool pprof** → Ferramenta avançada de análise de performance.

=== Como executar
[source,bash]
----
go run comandos.go
----

Ou gerar o binário:

[source,bash]
----
go build
./comandos
----

=== Conclusão
O programa apresenta, de forma clara e objetiva, os comandos mais importantes do Go para uso no terminal.
Ele funciona como um guia de consulta rápida para quem está aprendendo o ecossistema Go, cobrindo desde comandos básicos até ferramentas avançadas como pprof e vet.

= Exercício 3 - Constantes (const), Variáveis (var) e Inferência de Tipo utilizado somente dentro de função (:=)
:toc:

=== Resumo Rápido
Este exercício demonstra os conceitos de constantes, variáveis, inferência de tipos e os tipos primitivos básicos do Go. Ele apresenta de forma organizada como declarar valores, como o compilador infere tipos padrão e como usar a declaração curta := dentro de funções.

=== Objetivo
- Como declarar constantes e variáveis com ou sem tipo explícito.
- Como funciona a inferência de tipo e os tipos padrão do compilador (int, float64, complex128).
- Diferenças entre tipos numéricos, strings, runes e números complexos.
- Multi-atribuição e organização de blocos de constantes e variáveis.

O uso de Sprintf:
`fmt.Sprintf` é uma função do pacote `fmt` que permite **formatar valores em uma string**, usando **verbos de formatação**, sem imprimir nada no console. É útil para criar mensagens formatadas que serão armazenadas ou usadas em outras funções.

=== O que foi feito
O conteúdo estudado inclui:

- Constantes com tipo explícito e bloco de constantes com tipo inferido.
- Variáveis com tipo explícito, inferência via var e declaração curta :=.
- Tipos booleanos (bool) e sua inferência.
- Tipos numéricos inteiros (int8, uint8, int32, uint32, int) e floats (float32, float64).
- Strings e runes, com explicação sobre rune como alias de int32.
- Números complexos (complex64, complex128) e funções complex(), real() e imag().
- Multi-atribuição, mostrando como declarar e inicializar múltiplas variáveis em uma linha.
- Uso de pacotes e aliases, como m "math" para funções matemáticas.

- `fmt.Sprintf` recebe **um formato** (string) e **uma lista de valores**, retornando uma **string** formatada.

=== Verbos de formatação do fmt.Printf

Os seguintes verbos podem ser usados com todos os tipos de dados:

[options="header"]
|===
| Verbo | Descrição

| %v
| Imprime o valor no formato padrão

| %#v
| Imprime o valor no formato Go-syntax (com detalhes de tipo)

| %T
| Imprime o tipo da variável

| %%
| Imprime o caractere de porcentagem (%)
|===


Cada item inclui explicações sobre inferência de tipos e qual tipo padrão o Go atribui quando o tipo não é declarado explicitamente.

=== Conclusão
Apresenta um resumo didático dos tipos básicos do Go, constantes, variáveis e inferência de tipo, sem exibir o código fonte. É ideal como material de estudo para fixar conceitos antes de avançar para estruturas mais complexas como arrays, slices, maps e structs.

= Exercício 4 - tipos básicos
:toc:

=== Resumo Rápido
Este exercício demonstra os conceitos fundamentais dos **tipos básicos em Go**, incluindo inteiros, números reais, booleanos, strings, runes e inspeção de tipos usando `reflect.TypeOf`. Ele mostra, na prática, como a linguagem trata cada tipo primitivo e como esses valores são interpretados internamente.

=== Objetivo

* Entender como funcionam os tipos primitivos do Go.
* Visualizar como o compilador interpreta literais numéricos e string.
* Diferenciar tipos inteiros com e sem sinal (uint, int) e seus tamanhos.
* Compreender a representação de caracteres via rune (Unicode — int32).
* Explorar a diferença entre `float32` e `float64`.
* Observar o uso de `reflect.TypeOf` para inspeção de tipos.
* Analisar a diferença entre string comum e string multilinha com crase.

O uso de `reflect.TypeOf`:
`reflect.TypeOf` permite descobrir **exatamente o tipo** de uma variável ou literal em tempo de execução, sendo útil para estudo, debug ou validação de dados. : tipos numéricos, booleanos, strings, runes e inspeção de tipos com reflect.TypeOf.

=== O que foi feito
O conteúdo estudado inclui:

* Impressão e análise de tipos de valores inteiros (`int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`...).
* Uso do valor máximo de `int64` via `math.MaxInt64`.
* Declaração de um `byte` como alias de `uint8`.
* Declaração de `rune` (int32) para representar caracteres Unicode.
* Diferença entre float32 e float64 observada via tipos inferidos.
* Avaliação do tipo de booleanos (`bool`) e negação lógica.
* Strings simples e strings de múltiplas linhas usando crase.
* Explicação do porquê strings não são mutáveis e nunca usam aspas simples.
* Impressão do tamanho da string com `len()`.
* Demonstração de que caracteres entre aspas simples são tratados como `rune`.

=== Tabela de valores padrão na inferência de tipos (Go)

Quando você declara valores sem especificar o tipo explicitamente, o Go aplica tipos padrão conforme o literal usado. A tabela abaixo mostra como o compilador determina esses tipos:

[options="header"]
|===
| Literal / Forma de Declaração | Tipo Inferido | Valor Exemplo

| 10 | int | 10

| 10.0 | float64 | 10.0

| 49.99 | float64 | 49.99

| true / false | bool | true

| "texto" | string | "texto"

| 'a' | rune (int32) | 97 (código Unicode)

| var x | depende do valor atribuído | —

| := (atribuição curta) | tipo do literal usado | x := 5 → int / x := 2.5 → float64
|===

=== Conclusão
Este exercício permitiu compreender de forma prática como o Go lida com seus tipos primitivos, como inteiros, floats, booleanos, strings e runes. Também foi possível visualizar como o compilador infere tipos padrão a partir de literais, além de entender a utilidade de reflect.TypeOf para identificar o tipo real de cada valor em tempo de execução. O uso de strings comuns e multilinhas, a distinção entre caracteres e runes, e a análise do comportamento de cada tipo forneceram uma base sólida para aprofundar os estudos na linguagem. Os conceitos aqui trabalhados são fundamentais para os próximos temas, como arrays, slices, maps, ponteiros e estruturas mais avançadas.